# Prompt Chaining Result

## SCHEMA (Generated by GPT-3.5-turbo)
```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "price": {
      "type": "number",
      "minimum": 0
    },
    "stock": {
      "type": "integer",
      "minimum": 0
    }
  },
  "required": ["name"]
}
```

## ROUTES & HANDLERS (Go) (Generated by GPT-5-mini)
Below is a concise, production-oriented design for REST routes and idiomatic Go handlers for CRUD based on the provided schema (a "product" resource). The code shows:

- HTTP routes
- Request/response handling with validation
- Repository interface + simple in-memory implementation (concurrency-safe)
- Handlers: Create (POST), List (GET), Get (GET /{id}), Update (PUT), Delete (DELETE)
- Helpful utilities (JSON read/write, errors)

Put this in a single file for a small service; in a real service split into packages (api/handlers, model, store, server, etc.).

Notes:
- Uses github.com/google/uuid for UUID generation: go get github.com/google/uuid
- Uses only stdlib + uuid

```go
package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
)

// Product corresponds to the JSON schema
type Product struct {
	ID          string  `json:"id,omitempty"`
	Name        string  `json:"name"`
	Description string  `json:"description,omitempty"`
	Price       float64 `json:"price,omitempty"`
	Stock       int     `json:"stock,omitempty"`
	CreatedAt   string  `json:"created_at,omitempty"`
	UpdatedAt   string  `json:"updated_at,omitempty"`
}

// Validate returns an error when the product doesn't meet schema constraints.
// For create, ID may be empty.
func (p *Product) Validate() error {
	p.Name = strings.TrimSpace(p.Name)
	if p.Name == "" {
		return errors.New("name is required")
	}
	if p.Price < 0 {
		return errors.New("price must be >= 0")
	}
	if p.Stock < 0 {
		return errors.New("stock must be >= 0")
	}
	return nil
}

// Store is a repository abstraction for products.
type Store interface {
	Create(ctx context.Context, p *Product) error
	Get(ctx context.Context, id string) (*Product, error)
	List(ctx context.Context, limit, offset int) ([]*Product, error)
	Update(ctx context.Context, p *Product) error
	Delete(ctx context.Context, id string) error
}

// ErrNotFound returned when an entity is missing.
var ErrNotFound = errors.New("not found")

// InMemoryStore is a simple concurrency-safe store for demonstration.
type InMemoryStore struct {
	mu   sync.RWMutex
	data map[string]*Product
}

func NewInMemoryStore() *InMemoryStore {
	return &InMemoryStore{data: make(map[string]*Product)}
}

func (s *InMemoryStore) Create(ctx context.Context, p *Product) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	p.ID = uuid.New().String()
	now := time.Now().UTC().Format(time.RFC3339)
	p.CreatedAt = now
	p.UpdatedAt = now
	// make a copy
	cp := *p
	s.data[p.ID] = &cp
	return nil
}

func (s *InMemoryStore) Get(ctx context.Context, id string) (*Product, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if p, ok := s.data[id]; ok {
		cp := *p
		return &cp, nil
	}
	return nil, ErrNotFound
}

func (s *InMemoryStore) List(ctx context.Context, limit, offset int) ([]*Product, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	out := make([]*Product, 0, len(s.data))
	for _, p := range s.data {
		cp := *p
		out = append(out, &cp)
	}
	// simple deterministic ordering by ID for pagination stability
	// (for demo only; production would use DB ordering)
	// apply offset/limit
	if offset >= len(out) {
		return []*Product{}, nil
	}
	end := len(out)
	if limit > 0 && offset+limit < end {
		end = offset + limit
	}
	return out[offset:end], nil
}

func (s *InMemoryStore) Update(ctx context.Context, p *Product) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	existing, ok := s.data[p.ID]
	if !ok {
		return ErrNotFound
	}
	// replace allowed fields (ID, CreatedAt preserved)
	existing.Name = p.Name
	existing.Description = p.Description
	existing.Price = p.Price
	existing.Stock = p.Stock
	existing.UpdatedAt = time.Now().UTC().Format(time.RFC3339)
	return nil
}

func (s *InMemoryStore) Delete(ctx context.Context, id string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, ok := s.data[id]; !ok {
		return ErrNotFound
	}
	delete(s.data, id)
	return nil
}

// Handler holds dependencies for HTTP handlers.
type Handler struct {
	store Store
}

func NewHandler(store Store) *Handler { return &Handler{store: store} }

// Utilities for JSON responses
type apiError struct {
	Error string `json:"error"`
}

func writeJSON(w http.ResponseWriter, status int, v interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(v)
}

func writeError(w http.ResponseWriter, status int, err error) {
	writeJSON(w, status, apiError{Error: err.Error()})
}

// Routes:
// POST   /products        -> CreateProduct
// GET    /products        -> ListProducts?limit=&offset=
// GET    /products/{id}   -> GetProduct
// PUT    /products/{id}   -> UpdateProduct (replace)
// DELETE /products/{id}   -> DeleteProduct

// CreateProduct handles POST /products
func (h *Handler) CreateProduct(w http.ResponseWriter, r *http.Request) {
	var p Product
	dec := json.NewDecoder(r.Body)
	dec.DisallowUnknownFields()
	if err := dec.Decode(&p); err != nil {
		writeError(w, http.StatusBadRequest, fmt.Errorf("invalid json: %w", err))
		return
	}
	if err := p.Validate(); err != nil {
		writeError(w, http.StatusBadRequest, err)
		return
	}
	if err := h.store.Create(r.Context(), &p); err != nil {
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	w.Header().Set("Location", fmt.Sprintf("/products/%s", p.ID))
	writeJSON(w, http.StatusCreated, p)
}

// ListProducts handles GET /products
func (h *Handler) ListProducts(w http.ResponseWriter, r *http.Request) {
	q := r.URL.Query()
	limit := 0
	offset := 0
	if v := q.Get("limit"); v != "" {
		if i, err := strconv.Atoi(v); err == nil && i > 0 {
			limit = i
		}
	}
	if v := q.Get("offset"); v != "" {
		if i, err := strconv.Atoi(v); err == nil && i >= 0 {
			offset = i
		}
	}
	list, err := h.store.List(r.Context(), limit, offset)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	writeJSON(w, http.StatusOK, list)
}

// GetProduct handles GET /products/{id}
func (h *Handler) GetProduct(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/products/")
	if id == "" {
		writeError(w, http.StatusBadRequest, errors.New("missing id"))
		return
	}
	p, err := h.store.Get(r.Context(), id)
	if err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, err)
			return
		}
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	writeJSON(w, http.StatusOK, p)
}

// UpdateProduct handles PUT /products/{id} (full replace)
func (h *Handler) UpdateProduct(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/products/")
	if id == "" {
		writeError(w, http.StatusBadRequest, errors.New("missing id"))
		return
	}
	// ensure resource exists
	_, err := h.store.Get(r.Context(), id)
	if err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, err)
			return
		}
		writeError(w, http.StatusInternalServerError, err)
		return
	}

	var p Product
	dec := json.NewDecoder(r.Body)
	dec.DisallowUnknownFields()
	if err := dec.Decode(&p); err != nil {
		writeError(w, http.StatusBadRequest, err)
		return
	}
	// ensure the ID in payload (if present) matches path
	if p.ID != "" && p.ID != id {
		writeError(w, http.StatusBadRequest, errors.New("id in body must match URL"))
		return
	}
	p.ID = id
	if err := p.Validate(); err != nil {
		writeError(w, http.StatusBadRequest, err)
		return
	}
	if err := h.store.Update(r.Context(), &p); err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, err)
			return
		}
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	updated, _ := h.store.Get(r.Context(), id)
	writeJSON(w, http.StatusOK, updated)
}

// DeleteProduct handles DELETE /products/{id}
func (h *Handler) DeleteProduct(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/products/")
	if id == "" {
		writeError(w, http.StatusBadRequest, errors.New("missing id"))
		return
	}
	if err := h.store.Delete(r.Context(), id); err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, err)
			return
		}
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

func main() {
	store := NewInMemoryStore()
	h := NewHandler(store)

	mux := http.NewServeMux()
	// Routes:
	// POST /products
	mux.HandleFunc("/products", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			h.CreateProduct(w, r)
		case http.MethodGet:
			h.ListProducts(w, r)
		default:
			w.Header().Set("Allow", "GET, POST")
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	})
	// Single resource (crud)
	mux.HandleFunc("/products/", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			h.GetProduct(w, r)
		case http.MethodPut:
			h.UpdateProduct(w, r)
		case http.MethodDelete:
			h.DeleteProduct(w, r)
		default:
			w.Header().Set("Allow", "GET, PUT, DELETE")
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	})

	addr := ":8080"
	srv := &http.Server{
		Addr:    addr,
		Handler: loggingMiddleware(mux),
	}

	log.Printf("listening on %s", addr)
	log.Fatal(srv.ListenAndServe())
}

// loggingMiddleware is a tiny production-oriented middleware example.
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		log.Printf("%s %s %s", r.Method, r.URL.Path, time.Since(start))
	})
}
```

Usage examples (curl):
- Create:
  curl -X POST -H "Content-Type: application/json" -d '{"name":"Widget","price":9.99,"stock":100}' http://localhost:8080/products
- List:
  curl http://localhost:8080/products?limit=10&offset=0
- Get:
  curl http://localhost:8080/products/{id}
- Update:
  curl -X PUT -H "Content-Type: application/json" -d '{"name":"NewName","price":12.5,"stock":50}' http://localhost:8080/products/{id}
- Delete:
  curl -X DELETE http://localhost:8080/products/{id}

Notes for production hardening you should add:
- Proper structured logging and request IDs
- Timeouts on server and DB operations (context)
- Persistent storage (SQL/NoSQL) and migrations
- More extensive validation and schema-driven DTOs
- Authentication, RBAC, rate limiting, metrics, and tests

If you want, I can:
- Split code into packages
- Provide a Postgres-backed Store implementation
- Add PATCH semantics (partial updates) or OpenAPI spec generation.

## COMMIT (Generated by GPT-4o-mini)
```
feat(api): implement CRUD operations for product resource with validation and in-memory storage
```

---
**Pipeline Models:**
- Step 1: GPT-3.5-turbo
- Step 2: GPT-5-mini
- Step 3: GPT-4o-mini  

